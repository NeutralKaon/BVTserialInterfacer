/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "cmdline.h"

const char *gengetopt_args_info_purpose = "This dodgy command line tool acts as a command line interfacer with the Bruker\nBVT3000 NMR heater unit that uses a Eurotherm 902s PID controller. \n\nIt provides many silly, but hopefully useful, command line commands to check\nhardware status, measure things, and so on. Everything is either dreadfully\nverbose (with the -v switch), or alternatively consists of: \n'***XXXX: VALUE', where 'XXXX' depends on the command requested (e.g. TEMP) and\n'VALUE' is the return of that command. See the documentation (that I haven't\ncompletely yet written...) for more details.  Further documentation is\navailable with the --full-help option.\n\n";

const char *gengetopt_args_info_usage = "Usage: -d /path/to/serialPort command [command argument]";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "For variable temperature NMR experiments.";

const char *gengetopt_args_info_full_help[] = {
  "  -h, --help                    Print help and exit",
  "      --full-help               Print help, including hidden options, and exit",
  "  -V, --version                 Print version and exit",
  "\n Written by Jack J. Miller, University of Oxford, heavily ''inspired by'' code\nfrom Fsc2, a free spectrometer driving software, written by Jens Thoms\nToerring. \n\nLicensed under under the terms of the GNU General Public License, v3, or at\nyour choice any later license.\n\nGiven that this software can be used with hardware designed to cool samples to\n77 K or heat them to 1000 K, please particularly note the section of the GPL\ndisclaiming liability!\n",
  "  -v, --verbose                 Debugging verbosity  (default=off)",
  "\nSerial devices:",
  "  -d, --device=STRING           Serial port device to use\n                                  (default=`/dev/null')",
  "      --list-devices            List found serial devices for debugging\n                                  purposes (specify a dummy -d=Path)\n                                  (default=off)",
  "\nHeater controls:",
  "      --heater-on               Turn on the heater (Be careful!)  (default=off)",
  "  -O, --heater-off              Turn the heater off  (default=off)",
  "\n",
  "  -G, --get-heater-state        See if the heater is on or off  (default=off)",
  "      --set-heater-power-limit=FLOAT\n                                Live dangerously by increasing the maximum\n                                  heater power (a percentage between 0/100)",
  "      --get-heater-power-limit  Get the heater power limit  (default=off)",
  "      --get-heater-power        Get the current heater power (as a percentage)\n                                  (default=off)",
  "      --set-heater-power=FLOAT  Set the current heater power (as a percentage)",
  "  -X, --check-heater            Check to see if the heater is overheating\n                                  (default=off)",
  "\nGas flow controls:",
  "  -g, --get-gas-flow-rate       Return the gas flow rate in l/hr  (default=off)",
  "  -s, --set-gas-flow-rate=FLOAT Set the gas flow rate to one of 16 values\n                                  between 0 and 2000 l/hr. NB: 0 disables the\n                                  heater.",
  "\nTemperature methods:",
  "  -r, --read-temperature        Read temperature  (default=off)",
  "      --set-temperature-setpoint=FLOAT\n                                Set the temperature setpoint",
  "  -R, --get-temperature-setpoint\n                                Get the current temperature setpoint\n                                  (default=off)",
  "\nLiquid Nitrogen methods (NB: you need the optional N2 evaporator):",
  "      --get-ln2-heater-state    Get the LN2 heater state (on/off)\n                                  (default=off)",
  "      --set-ln2-heater-state=INT\n                                Turn on/off the LN2 heater (1=on)",
  "      --get-ln2-heater-power    Get the LN2 heater power  (default=off)",
  "      --set-ln2-heater-power=FLOAT\n                                Set the LN2 heater power (as a percentage)",
  "      --check-ln2-heater        Check the LN2 tank to see if it is okay, needs\n                                  a refil, or is empty  (default=off)",
  "\nPID control:",
  "  -E, --enable-PID-control      Enable the PID control of temperature to the\n                                  setpoint  (default=off)",
  "  -M, --manual-mode             Set the device into manual heater power mode\n                                  (default=off)",
  "      --get-mode                Return the current PID / Manual control mode\n                                    (default=off)",
  "      --set-proportional-band=FLOAT\n                                Set the P part of PID",
  "      --get-proportional-band   Get the P part of PID  (default=off)",
  "      --set-integral-time=FLOAT Set the I part of PID",
  "      --get-integral-time       Get the I part of PID  (default=off)",
  "      --set-differential-time=FLOAT\n                                Set the D part of PID",
  "      --get-differential-time   Get the D in the PID\n                                    (default=off)",
  "      --get-high-cutback        Get the high cutback value  (default=off)",
  "      --set-high-cutback=FLOAT  Set the high cutback value",
  "      --get-low-cutback         Get the low cutback value  (default=off)",
  "      --set-low-cutback=FLOAT   Set the low cutback value",
  "      --get-adaptive-tune-level Get the adaptive tune level (K)  (default=off)",
  "      --set-adaptive-tune-level=FLOAT\n                                Set the adaptive tune level (K)",
  "\nMisc. methods:",
  "      --lock-keypad=INT         Unlock (1) or lock (0) the Eurotherm keypad",
  "      --get-eurotherm-status    Get the status of the Eurotherm controller\n                                  (alarming or not)  (default=off)",
  "      --status-all              Return the status of everything that is a\n                                  status  (default=off)",
  "      --check-sensor-break      Check to see if the Thermocouples are broken\n                                  (default=off)",
  "\n Example invocation to read temperature (K), and gas flow rate (l/hours): \n\n BVTserialInterfacer -d /dev/ttyUSB0 -r --get-gas-flow-rate\n",
    0
};

static void
init_help_array(void)
{
  gengetopt_args_info_help[0] = gengetopt_args_info_full_help[0];
  gengetopt_args_info_help[1] = gengetopt_args_info_full_help[1];
  gengetopt_args_info_help[2] = gengetopt_args_info_full_help[2];
  gengetopt_args_info_help[3] = gengetopt_args_info_full_help[3];
  gengetopt_args_info_help[4] = gengetopt_args_info_full_help[4];
  gengetopt_args_info_help[5] = gengetopt_args_info_full_help[5];
  gengetopt_args_info_help[6] = gengetopt_args_info_full_help[6];
  gengetopt_args_info_help[7] = gengetopt_args_info_full_help[7];
  gengetopt_args_info_help[8] = gengetopt_args_info_full_help[8];
  gengetopt_args_info_help[9] = gengetopt_args_info_full_help[9];
  gengetopt_args_info_help[10] = gengetopt_args_info_full_help[10];
  gengetopt_args_info_help[11] = gengetopt_args_info_full_help[11];
  gengetopt_args_info_help[12] = gengetopt_args_info_full_help[12];
  gengetopt_args_info_help[13] = gengetopt_args_info_full_help[15];
  gengetopt_args_info_help[14] = gengetopt_args_info_full_help[16];
  gengetopt_args_info_help[15] = gengetopt_args_info_full_help[17];
  gengetopt_args_info_help[16] = gengetopt_args_info_full_help[18];
  gengetopt_args_info_help[17] = gengetopt_args_info_full_help[19];
  gengetopt_args_info_help[18] = gengetopt_args_info_full_help[20];
  gengetopt_args_info_help[19] = gengetopt_args_info_full_help[21];
  gengetopt_args_info_help[20] = gengetopt_args_info_full_help[22];
  gengetopt_args_info_help[21] = gengetopt_args_info_full_help[23];
  gengetopt_args_info_help[22] = gengetopt_args_info_full_help[24];
  gengetopt_args_info_help[23] = gengetopt_args_info_full_help[47];
  gengetopt_args_info_help[24] = gengetopt_args_info_full_help[49];
  gengetopt_args_info_help[25] = gengetopt_args_info_full_help[50];
  gengetopt_args_info_help[26] = gengetopt_args_info_full_help[51];
  gengetopt_args_info_help[27] = gengetopt_args_info_full_help[52];
  gengetopt_args_info_help[28] = 0; 
  
}

const char *gengetopt_args_info_help[29];

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
  , ARG_FLOAT
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->full_help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->verbose_given = 0 ;
  args_info->device_given = 0 ;
  args_info->list_devices_given = 0 ;
  args_info->heater_on_given = 0 ;
  args_info->heater_off_given = 0 ;
  args_info->get_heater_state_given = 0 ;
  args_info->set_heater_power_limit_given = 0 ;
  args_info->get_heater_power_limit_given = 0 ;
  args_info->get_heater_power_given = 0 ;
  args_info->set_heater_power_given = 0 ;
  args_info->check_heater_given = 0 ;
  args_info->get_gas_flow_rate_given = 0 ;
  args_info->set_gas_flow_rate_given = 0 ;
  args_info->read_temperature_given = 0 ;
  args_info->set_temperature_setpoint_given = 0 ;
  args_info->get_temperature_setpoint_given = 0 ;
  args_info->get_ln2_heater_state_given = 0 ;
  args_info->set_ln2_heater_state_given = 0 ;
  args_info->get_ln2_heater_power_given = 0 ;
  args_info->set_ln2_heater_power_given = 0 ;
  args_info->check_ln2_heater_given = 0 ;
  args_info->enable_PID_control_given = 0 ;
  args_info->manual_mode_given = 0 ;
  args_info->get_mode_given = 0 ;
  args_info->set_proportional_band_given = 0 ;
  args_info->get_proportional_band_given = 0 ;
  args_info->set_integral_time_given = 0 ;
  args_info->get_integral_time_given = 0 ;
  args_info->set_differential_time_given = 0 ;
  args_info->get_differential_time_given = 0 ;
  args_info->get_high_cutback_given = 0 ;
  args_info->set_high_cutback_given = 0 ;
  args_info->get_low_cutback_given = 0 ;
  args_info->set_low_cutback_given = 0 ;
  args_info->get_adaptive_tune_level_given = 0 ;
  args_info->set_adaptive_tune_level_given = 0 ;
  args_info->lock_keypad_given = 0 ;
  args_info->get_eurotherm_status_given = 0 ;
  args_info->status_all_given = 0 ;
  args_info->check_sensor_break_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->verbose_flag = 0;
  args_info->device_arg = gengetopt_strdup ("/dev/null");
  args_info->device_orig = NULL;
  args_info->list_devices_flag = 0;
  args_info->heater_on_flag = 0;
  args_info->heater_off_flag = 0;
  args_info->get_heater_state_flag = 0;
  args_info->set_heater_power_limit_orig = NULL;
  args_info->get_heater_power_limit_flag = 0;
  args_info->get_heater_power_flag = 0;
  args_info->set_heater_power_orig = NULL;
  args_info->check_heater_flag = 0;
  args_info->get_gas_flow_rate_flag = 0;
  args_info->set_gas_flow_rate_orig = NULL;
  args_info->read_temperature_flag = 0;
  args_info->set_temperature_setpoint_orig = NULL;
  args_info->get_temperature_setpoint_flag = 0;
  args_info->get_ln2_heater_state_flag = 0;
  args_info->set_ln2_heater_state_orig = NULL;
  args_info->get_ln2_heater_power_flag = 0;
  args_info->set_ln2_heater_power_orig = NULL;
  args_info->check_ln2_heater_flag = 0;
  args_info->enable_PID_control_flag = 0;
  args_info->manual_mode_flag = 0;
  args_info->get_mode_flag = 0;
  args_info->set_proportional_band_orig = NULL;
  args_info->get_proportional_band_flag = 0;
  args_info->set_integral_time_orig = NULL;
  args_info->get_integral_time_flag = 0;
  args_info->set_differential_time_orig = NULL;
  args_info->get_differential_time_flag = 0;
  args_info->get_high_cutback_flag = 0;
  args_info->set_high_cutback_orig = NULL;
  args_info->get_low_cutback_flag = 0;
  args_info->set_low_cutback_orig = NULL;
  args_info->get_adaptive_tune_level_flag = 0;
  args_info->set_adaptive_tune_level_orig = NULL;
  args_info->lock_keypad_orig = NULL;
  args_info->get_eurotherm_status_flag = 0;
  args_info->status_all_flag = 0;
  args_info->check_sensor_break_flag = 0;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{

  init_help_array(); 
  args_info->help_help = gengetopt_args_info_full_help[0] ;
  args_info->full_help_help = gengetopt_args_info_full_help[1] ;
  args_info->version_help = gengetopt_args_info_full_help[2] ;
  args_info->verbose_help = gengetopt_args_info_full_help[4] ;
  args_info->device_help = gengetopt_args_info_full_help[6] ;
  args_info->list_devices_help = gengetopt_args_info_full_help[7] ;
  args_info->heater_on_help = gengetopt_args_info_full_help[9] ;
  args_info->heater_off_help = gengetopt_args_info_full_help[10] ;
  args_info->get_heater_state_help = gengetopt_args_info_full_help[12] ;
  args_info->set_heater_power_limit_help = gengetopt_args_info_full_help[13] ;
  args_info->get_heater_power_limit_help = gengetopt_args_info_full_help[14] ;
  args_info->get_heater_power_help = gengetopt_args_info_full_help[15] ;
  args_info->set_heater_power_help = gengetopt_args_info_full_help[16] ;
  args_info->check_heater_help = gengetopt_args_info_full_help[17] ;
  args_info->get_gas_flow_rate_help = gengetopt_args_info_full_help[19] ;
  args_info->set_gas_flow_rate_help = gengetopt_args_info_full_help[20] ;
  args_info->read_temperature_help = gengetopt_args_info_full_help[22] ;
  args_info->set_temperature_setpoint_help = gengetopt_args_info_full_help[23] ;
  args_info->get_temperature_setpoint_help = gengetopt_args_info_full_help[24] ;
  args_info->get_ln2_heater_state_help = gengetopt_args_info_full_help[26] ;
  args_info->set_ln2_heater_state_help = gengetopt_args_info_full_help[27] ;
  args_info->get_ln2_heater_power_help = gengetopt_args_info_full_help[28] ;
  args_info->set_ln2_heater_power_help = gengetopt_args_info_full_help[29] ;
  args_info->check_ln2_heater_help = gengetopt_args_info_full_help[30] ;
  args_info->enable_PID_control_help = gengetopt_args_info_full_help[32] ;
  args_info->manual_mode_help = gengetopt_args_info_full_help[33] ;
  args_info->get_mode_help = gengetopt_args_info_full_help[34] ;
  args_info->set_proportional_band_help = gengetopt_args_info_full_help[35] ;
  args_info->get_proportional_band_help = gengetopt_args_info_full_help[36] ;
  args_info->set_integral_time_help = gengetopt_args_info_full_help[37] ;
  args_info->get_integral_time_help = gengetopt_args_info_full_help[38] ;
  args_info->set_differential_time_help = gengetopt_args_info_full_help[39] ;
  args_info->get_differential_time_help = gengetopt_args_info_full_help[40] ;
  args_info->get_high_cutback_help = gengetopt_args_info_full_help[41] ;
  args_info->set_high_cutback_help = gengetopt_args_info_full_help[42] ;
  args_info->get_low_cutback_help = gengetopt_args_info_full_help[43] ;
  args_info->set_low_cutback_help = gengetopt_args_info_full_help[44] ;
  args_info->get_adaptive_tune_level_help = gengetopt_args_info_full_help[45] ;
  args_info->set_adaptive_tune_level_help = gengetopt_args_info_full_help[46] ;
  args_info->lock_keypad_help = gengetopt_args_info_full_help[48] ;
  args_info->get_eurotherm_status_help = gengetopt_args_info_full_help[49] ;
  args_info->status_all_help = gengetopt_args_info_full_help[50] ;
  args_info->check_sensor_break_help = gengetopt_args_info_full_help[51] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_print_full_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_full_help[i])
    printf("%s\n", gengetopt_args_info_full_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

  free_string_field (&(args_info->device_arg));
  free_string_field (&(args_info->device_orig));
  free_string_field (&(args_info->set_heater_power_limit_orig));
  free_string_field (&(args_info->set_heater_power_orig));
  free_string_field (&(args_info->set_gas_flow_rate_orig));
  free_string_field (&(args_info->set_temperature_setpoint_orig));
  free_string_field (&(args_info->set_ln2_heater_state_orig));
  free_string_field (&(args_info->set_ln2_heater_power_orig));
  free_string_field (&(args_info->set_proportional_band_orig));
  free_string_field (&(args_info->set_integral_time_orig));
  free_string_field (&(args_info->set_differential_time_orig));
  free_string_field (&(args_info->set_high_cutback_orig));
  free_string_field (&(args_info->set_low_cutback_orig));
  free_string_field (&(args_info->set_adaptive_tune_level_orig));
  free_string_field (&(args_info->lock_keypad_orig));
  
  

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->full_help_given)
    write_into_file(outfile, "full-help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->verbose_given)
    write_into_file(outfile, "verbose", 0, 0 );
  if (args_info->device_given)
    write_into_file(outfile, "device", args_info->device_orig, 0);
  if (args_info->list_devices_given)
    write_into_file(outfile, "list-devices", 0, 0 );
  if (args_info->heater_on_given)
    write_into_file(outfile, "heater-on", 0, 0 );
  if (args_info->heater_off_given)
    write_into_file(outfile, "heater-off", 0, 0 );
  if (args_info->get_heater_state_given)
    write_into_file(outfile, "get-heater-state", 0, 0 );
  if (args_info->set_heater_power_limit_given)
    write_into_file(outfile, "set-heater-power-limit", args_info->set_heater_power_limit_orig, 0);
  if (args_info->get_heater_power_limit_given)
    write_into_file(outfile, "get-heater-power-limit", 0, 0 );
  if (args_info->get_heater_power_given)
    write_into_file(outfile, "get-heater-power", 0, 0 );
  if (args_info->set_heater_power_given)
    write_into_file(outfile, "set-heater-power", args_info->set_heater_power_orig, 0);
  if (args_info->check_heater_given)
    write_into_file(outfile, "check-heater", 0, 0 );
  if (args_info->get_gas_flow_rate_given)
    write_into_file(outfile, "get-gas-flow-rate", 0, 0 );
  if (args_info->set_gas_flow_rate_given)
    write_into_file(outfile, "set-gas-flow-rate", args_info->set_gas_flow_rate_orig, 0);
  if (args_info->read_temperature_given)
    write_into_file(outfile, "read-temperature", 0, 0 );
  if (args_info->set_temperature_setpoint_given)
    write_into_file(outfile, "set-temperature-setpoint", args_info->set_temperature_setpoint_orig, 0);
  if (args_info->get_temperature_setpoint_given)
    write_into_file(outfile, "get-temperature-setpoint", 0, 0 );
  if (args_info->get_ln2_heater_state_given)
    write_into_file(outfile, "get-ln2-heater-state", 0, 0 );
  if (args_info->set_ln2_heater_state_given)
    write_into_file(outfile, "set-ln2-heater-state", args_info->set_ln2_heater_state_orig, 0);
  if (args_info->get_ln2_heater_power_given)
    write_into_file(outfile, "get-ln2-heater-power", 0, 0 );
  if (args_info->set_ln2_heater_power_given)
    write_into_file(outfile, "set-ln2-heater-power", args_info->set_ln2_heater_power_orig, 0);
  if (args_info->check_ln2_heater_given)
    write_into_file(outfile, "check-ln2-heater", 0, 0 );
  if (args_info->enable_PID_control_given)
    write_into_file(outfile, "enable-PID-control", 0, 0 );
  if (args_info->manual_mode_given)
    write_into_file(outfile, "manual-mode", 0, 0 );
  if (args_info->get_mode_given)
    write_into_file(outfile, "get-mode", 0, 0 );
  if (args_info->set_proportional_band_given)
    write_into_file(outfile, "set-proportional-band", args_info->set_proportional_band_orig, 0);
  if (args_info->get_proportional_band_given)
    write_into_file(outfile, "get-proportional-band", 0, 0 );
  if (args_info->set_integral_time_given)
    write_into_file(outfile, "set-integral-time", args_info->set_integral_time_orig, 0);
  if (args_info->get_integral_time_given)
    write_into_file(outfile, "get-integral-time", 0, 0 );
  if (args_info->set_differential_time_given)
    write_into_file(outfile, "set-differential-time", args_info->set_differential_time_orig, 0);
  if (args_info->get_differential_time_given)
    write_into_file(outfile, "get-differential-time", 0, 0 );
  if (args_info->get_high_cutback_given)
    write_into_file(outfile, "get-high-cutback", 0, 0 );
  if (args_info->set_high_cutback_given)
    write_into_file(outfile, "set-high-cutback", args_info->set_high_cutback_orig, 0);
  if (args_info->get_low_cutback_given)
    write_into_file(outfile, "get-low-cutback", 0, 0 );
  if (args_info->set_low_cutback_given)
    write_into_file(outfile, "set-low-cutback", args_info->set_low_cutback_orig, 0);
  if (args_info->get_adaptive_tune_level_given)
    write_into_file(outfile, "get-adaptive-tune-level", 0, 0 );
  if (args_info->set_adaptive_tune_level_given)
    write_into_file(outfile, "set-adaptive-tune-level", args_info->set_adaptive_tune_level_orig, 0);
  if (args_info->lock_keypad_given)
    write_into_file(outfile, "lock-keypad", args_info->lock_keypad_orig, 0);
  if (args_info->get_eurotherm_status_given)
    write_into_file(outfile, "get-eurotherm-status", 0, 0 );
  if (args_info->status_all_given)
    write_into_file(outfile, "status-all", 0, 0 );
  if (args_info->check_sensor_break_given)
    write_into_file(outfile, "check-sensor-break", 0, 0 );
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (! args_info->device_given)
    {
      fprintf (stderr, "%s: '--device' ('-d') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  
  /* checks for dependences among options */

  return error_occurred;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_FLOAT:
    if (val) *((float *)field) = (float)strtod (val, &stop_char);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_FLOAT:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "full-help",	0, NULL, 0 },
        { "version",	0, NULL, 'V' },
        { "verbose",	0, NULL, 'v' },
        { "device",	1, NULL, 'd' },
        { "list-devices",	0, NULL, 0 },
        { "heater-on",	0, NULL, 0 },
        { "heater-off",	0, NULL, 'O' },
        { "get-heater-state",	0, NULL, 'G' },
        { "set-heater-power-limit",	1, NULL, 0 },
        { "get-heater-power-limit",	0, NULL, 0 },
        { "get-heater-power",	0, NULL, 0 },
        { "set-heater-power",	1, NULL, 0 },
        { "check-heater",	0, NULL, 'X' },
        { "get-gas-flow-rate",	0, NULL, 'g' },
        { "set-gas-flow-rate",	1, NULL, 's' },
        { "read-temperature",	0, NULL, 'r' },
        { "set-temperature-setpoint",	1, NULL, 0 },
        { "get-temperature-setpoint",	0, NULL, 'R' },
        { "get-ln2-heater-state",	0, NULL, 0 },
        { "set-ln2-heater-state",	1, NULL, 0 },
        { "get-ln2-heater-power",	0, NULL, 0 },
        { "set-ln2-heater-power",	1, NULL, 0 },
        { "check-ln2-heater",	0, NULL, 0 },
        { "enable-PID-control",	0, NULL, 'E' },
        { "manual-mode",	0, NULL, 'M' },
        { "get-mode",	0, NULL, 0 },
        { "set-proportional-band",	1, NULL, 0 },
        { "get-proportional-band",	0, NULL, 0 },
        { "set-integral-time",	1, NULL, 0 },
        { "get-integral-time",	0, NULL, 0 },
        { "set-differential-time",	1, NULL, 0 },
        { "get-differential-time",	0, NULL, 0 },
        { "get-high-cutback",	0, NULL, 0 },
        { "set-high-cutback",	1, NULL, 0 },
        { "get-low-cutback",	0, NULL, 0 },
        { "set-low-cutback",	1, NULL, 0 },
        { "get-adaptive-tune-level",	0, NULL, 0 },
        { "set-adaptive-tune-level",	1, NULL, 0 },
        { "lock-keypad",	1, NULL, 0 },
        { "get-eurotherm-status",	0, NULL, 0 },
        { "status-all",	0, NULL, 0 },
        { "check-sensor-break",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hVvd:OGXgs:rREM", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'v':	/* Debugging verbosity.  */
        
        
          if (update_arg((void *)&(args_info->verbose_flag), 0, &(args_info->verbose_given),
              &(local_args_info.verbose_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "verbose", 'v',
              additional_error))
            goto failure;
        
          break;
        case 'd':	/* Serial port device to use.  */
        
        
          if (update_arg( (void *)&(args_info->device_arg), 
               &(args_info->device_orig), &(args_info->device_given),
              &(local_args_info.device_given), optarg, 0, "/dev/null", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "device", 'd',
              additional_error))
            goto failure;
        
          break;
        case 'O':	/* Turn the heater off.  */
        
        
          if (update_arg((void *)&(args_info->heater_off_flag), 0, &(args_info->heater_off_given),
              &(local_args_info.heater_off_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "heater-off", 'O',
              additional_error))
            goto failure;
        
          break;
        case 'G':	/* See if the heater is on or off.  */
        
        
          if (update_arg((void *)&(args_info->get_heater_state_flag), 0, &(args_info->get_heater_state_given),
              &(local_args_info.get_heater_state_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "get-heater-state", 'G',
              additional_error))
            goto failure;
        
          break;
        case 'X':	/* Check to see if the heater is overheating.  */
        
        
          if (update_arg((void *)&(args_info->check_heater_flag), 0, &(args_info->check_heater_given),
              &(local_args_info.check_heater_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "check-heater", 'X',
              additional_error))
            goto failure;
        
          break;
        case 'g':	/* Return the gas flow rate in l/hr.  */
        
        
          if (update_arg((void *)&(args_info->get_gas_flow_rate_flag), 0, &(args_info->get_gas_flow_rate_given),
              &(local_args_info.get_gas_flow_rate_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "get-gas-flow-rate", 'g',
              additional_error))
            goto failure;
        
          break;
        case 's':	/* Set the gas flow rate to one of 16 values between 0 and 2000 l/hr. NB: 0 disables the heater..  */
        
        
          if (update_arg( (void *)&(args_info->set_gas_flow_rate_arg), 
               &(args_info->set_gas_flow_rate_orig), &(args_info->set_gas_flow_rate_given),
              &(local_args_info.set_gas_flow_rate_given), optarg, 0, 0, ARG_FLOAT,
              check_ambiguity, override, 0, 0,
              "set-gas-flow-rate", 's',
              additional_error))
            goto failure;
        
          break;
        case 'r':	/* Read temperature.  */
        
        
          if (update_arg((void *)&(args_info->read_temperature_flag), 0, &(args_info->read_temperature_given),
              &(local_args_info.read_temperature_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "read-temperature", 'r',
              additional_error))
            goto failure;
        
          break;
        case 'R':	/* Get the current temperature setpoint.  */
        
        
          if (update_arg((void *)&(args_info->get_temperature_setpoint_flag), 0, &(args_info->get_temperature_setpoint_given),
              &(local_args_info.get_temperature_setpoint_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "get-temperature-setpoint", 'R',
              additional_error))
            goto failure;
        
          break;
        case 'E':	/* Enable the PID control of temperature to the setpoint.  */
        
        
          if (update_arg((void *)&(args_info->enable_PID_control_flag), 0, &(args_info->enable_PID_control_given),
              &(local_args_info.enable_PID_control_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "enable-PID-control", 'E',
              additional_error))
            goto failure;
        
          break;
        case 'M':	/* Set the device into manual heater power mode.  */
        
        
          if (update_arg((void *)&(args_info->manual_mode_flag), 0, &(args_info->manual_mode_given),
              &(local_args_info.manual_mode_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "manual-mode", 'M',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          if (strcmp (long_options[option_index].name, "full-help") == 0) {
            cmdline_parser_print_full_help ();
            cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);
          }

          /* List found serial devices for debugging purposes (specify a dummy -d=Path).  */
          if (strcmp (long_options[option_index].name, "list-devices") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->list_devices_flag), 0, &(args_info->list_devices_given),
                &(local_args_info.list_devices_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "list-devices", '-',
                additional_error))
              goto failure;
          
          }
          /* Turn on the heater (Be careful!).  */
          else if (strcmp (long_options[option_index].name, "heater-on") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->heater_on_flag), 0, &(args_info->heater_on_given),
                &(local_args_info.heater_on_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "heater-on", '-',
                additional_error))
              goto failure;
          
          }
          /* Live dangerously by increasing the maximum heater power (a percentage between 0/100).  */
          else if (strcmp (long_options[option_index].name, "set-heater-power-limit") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_heater_power_limit_arg), 
                 &(args_info->set_heater_power_limit_orig), &(args_info->set_heater_power_limit_given),
                &(local_args_info.set_heater_power_limit_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-heater-power-limit", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the heater power limit.  */
          else if (strcmp (long_options[option_index].name, "get-heater-power-limit") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_heater_power_limit_flag), 0, &(args_info->get_heater_power_limit_given),
                &(local_args_info.get_heater_power_limit_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-heater-power-limit", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the current heater power (as a percentage).  */
          else if (strcmp (long_options[option_index].name, "get-heater-power") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_heater_power_flag), 0, &(args_info->get_heater_power_given),
                &(local_args_info.get_heater_power_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-heater-power", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the current heater power (as a percentage).  */
          else if (strcmp (long_options[option_index].name, "set-heater-power") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_heater_power_arg), 
                 &(args_info->set_heater_power_orig), &(args_info->set_heater_power_given),
                &(local_args_info.set_heater_power_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-heater-power", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the temperature setpoint.  */
          else if (strcmp (long_options[option_index].name, "set-temperature-setpoint") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_temperature_setpoint_arg), 
                 &(args_info->set_temperature_setpoint_orig), &(args_info->set_temperature_setpoint_given),
                &(local_args_info.set_temperature_setpoint_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-temperature-setpoint", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the LN2 heater state (on/off).  */
          else if (strcmp (long_options[option_index].name, "get-ln2-heater-state") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_ln2_heater_state_flag), 0, &(args_info->get_ln2_heater_state_given),
                &(local_args_info.get_ln2_heater_state_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-ln2-heater-state", '-',
                additional_error))
              goto failure;
          
          }
          /* Turn on/off the LN2 heater (1=on).  */
          else if (strcmp (long_options[option_index].name, "set-ln2-heater-state") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_ln2_heater_state_arg), 
                 &(args_info->set_ln2_heater_state_orig), &(args_info->set_ln2_heater_state_given),
                &(local_args_info.set_ln2_heater_state_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "set-ln2-heater-state", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the LN2 heater power.  */
          else if (strcmp (long_options[option_index].name, "get-ln2-heater-power") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_ln2_heater_power_flag), 0, &(args_info->get_ln2_heater_power_given),
                &(local_args_info.get_ln2_heater_power_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-ln2-heater-power", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the LN2 heater power (as a percentage).  */
          else if (strcmp (long_options[option_index].name, "set-ln2-heater-power") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_ln2_heater_power_arg), 
                 &(args_info->set_ln2_heater_power_orig), &(args_info->set_ln2_heater_power_given),
                &(local_args_info.set_ln2_heater_power_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-ln2-heater-power", '-',
                additional_error))
              goto failure;
          
          }
          /* Check the LN2 tank to see if it is okay, needs a refil, or is empty.  */
          else if (strcmp (long_options[option_index].name, "check-ln2-heater") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->check_ln2_heater_flag), 0, &(args_info->check_ln2_heater_given),
                &(local_args_info.check_ln2_heater_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "check-ln2-heater", '-',
                additional_error))
              goto failure;
          
          }
          /* Return the current PID / Manual control mode
.  */
          else if (strcmp (long_options[option_index].name, "get-mode") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_mode_flag), 0, &(args_info->get_mode_given),
                &(local_args_info.get_mode_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-mode", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the P part of PID.  */
          else if (strcmp (long_options[option_index].name, "set-proportional-band") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_proportional_band_arg), 
                 &(args_info->set_proportional_band_orig), &(args_info->set_proportional_band_given),
                &(local_args_info.set_proportional_band_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-proportional-band", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the P part of PID.  */
          else if (strcmp (long_options[option_index].name, "get-proportional-band") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_proportional_band_flag), 0, &(args_info->get_proportional_band_given),
                &(local_args_info.get_proportional_band_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-proportional-band", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the I part of PID.  */
          else if (strcmp (long_options[option_index].name, "set-integral-time") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_integral_time_arg), 
                 &(args_info->set_integral_time_orig), &(args_info->set_integral_time_given),
                &(local_args_info.set_integral_time_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-integral-time", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the I part of PID.  */
          else if (strcmp (long_options[option_index].name, "get-integral-time") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_integral_time_flag), 0, &(args_info->get_integral_time_given),
                &(local_args_info.get_integral_time_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-integral-time", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the D part of PID.  */
          else if (strcmp (long_options[option_index].name, "set-differential-time") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_differential_time_arg), 
                 &(args_info->set_differential_time_orig), &(args_info->set_differential_time_given),
                &(local_args_info.set_differential_time_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-differential-time", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the D in the PID
.  */
          else if (strcmp (long_options[option_index].name, "get-differential-time") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_differential_time_flag), 0, &(args_info->get_differential_time_given),
                &(local_args_info.get_differential_time_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-differential-time", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the high cutback value.  */
          else if (strcmp (long_options[option_index].name, "get-high-cutback") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_high_cutback_flag), 0, &(args_info->get_high_cutback_given),
                &(local_args_info.get_high_cutback_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-high-cutback", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the high cutback value.  */
          else if (strcmp (long_options[option_index].name, "set-high-cutback") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_high_cutback_arg), 
                 &(args_info->set_high_cutback_orig), &(args_info->set_high_cutback_given),
                &(local_args_info.set_high_cutback_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-high-cutback", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the low cutback value.  */
          else if (strcmp (long_options[option_index].name, "get-low-cutback") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_low_cutback_flag), 0, &(args_info->get_low_cutback_given),
                &(local_args_info.get_low_cutback_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-low-cutback", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the low cutback value.  */
          else if (strcmp (long_options[option_index].name, "set-low-cutback") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_low_cutback_arg), 
                 &(args_info->set_low_cutback_orig), &(args_info->set_low_cutback_given),
                &(local_args_info.set_low_cutback_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-low-cutback", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the adaptive tune level (K).  */
          else if (strcmp (long_options[option_index].name, "get-adaptive-tune-level") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_adaptive_tune_level_flag), 0, &(args_info->get_adaptive_tune_level_given),
                &(local_args_info.get_adaptive_tune_level_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-adaptive-tune-level", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the adaptive tune level (K).  */
          else if (strcmp (long_options[option_index].name, "set-adaptive-tune-level") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->set_adaptive_tune_level_arg), 
                 &(args_info->set_adaptive_tune_level_orig), &(args_info->set_adaptive_tune_level_given),
                &(local_args_info.set_adaptive_tune_level_given), optarg, 0, 0, ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "set-adaptive-tune-level", '-',
                additional_error))
              goto failure;
          
          }
          /* Unlock (1) or lock (0) the Eurotherm keypad.  */
          else if (strcmp (long_options[option_index].name, "lock-keypad") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->lock_keypad_arg), 
                 &(args_info->lock_keypad_orig), &(args_info->lock_keypad_given),
                &(local_args_info.lock_keypad_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "lock-keypad", '-',
                additional_error))
              goto failure;
          
          }
          /* Get the status of the Eurotherm controller (alarming or not).  */
          else if (strcmp (long_options[option_index].name, "get-eurotherm-status") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->get_eurotherm_status_flag), 0, &(args_info->get_eurotherm_status_given),
                &(local_args_info.get_eurotherm_status_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "get-eurotherm-status", '-',
                additional_error))
              goto failure;
          
          }
          /* Return the status of everything that is a status.  */
          else if (strcmp (long_options[option_index].name, "status-all") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->status_all_flag), 0, &(args_info->status_all_given),
                &(local_args_info.status_all_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "status-all", '-',
                additional_error))
              goto failure;
          
          }
          /* Check to see if the Thermocouples are broken.  */
          else if (strcmp (long_options[option_index].name, "check-sensor-break") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->check_sensor_break_flag), 0, &(args_info->check_sensor_break_given),
                &(local_args_info.check_sensor_break_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "check-sensor-break", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
